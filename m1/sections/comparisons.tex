%!TEX root = ../main.tex

\section{Choices and Comparisons}\label{section:comparisons}

We here give a rationale for design decisions and the chosen system model, as well as an explanation of known advantages and limitations compared to other options and approaches.
$\frost$ is backwards compatible with any protocol using the FIPS186-5 verifier. 
This is the NIST standardised Edwards-curve Digital Signature Algorithm (EdDSA) digital signature scheme \cite{EdDSA}.
EdDSA is a variant of Schnorr signature based on twisted Edwards curves.
No changes to existing implementations of the signature format or the verifier are required.
The signing procedure, however, is changed to support threshold signers.

In \cref{table:comparisons} we compare $\frost$ with other approaches in the literature.
We limit our comparisons to other concurrently secure threshold signatures that are also backwards compatible with FIPS186-5.
This includes
\begin{itemize}
	\item An unnamed protocol by Gennaro, Jarecki, Krawczyk and Rabin \cite{GennaroJKR01}
	\item An unnamed protocol by Stinson and Strobl \cite{StinsonS01}
	\item $\mathsf{2SCHNORR}$ by Nicolosi, Krohn, Dodis, and Mazi\`eres \cite{NicolosiKDM03}
	\item $\mathsf{CLASSICS}$ and $\mathsf{ZEROS}$ by Makriyannis \cite{Makriyannis22}	
	\item An unnamed protocol by Lindell \cite{Lindell22}
	\item $\mathsf{ROAST}$ by Ruffing, Ronge, Jin, Schneider{-}Bensch, and Schr{\"{o}}der \cite{RuffingRJSS22}
	\item $\mathsf{SPARKLE}$ by Crites, Komlo, and Maller \cite{CritesKM23}
	\item $\mathsf{SPRINT}$ by Benhamouda, Halevi, Krawczyk, Rabin and Ma \cite{BenhamoudaHKRM23}
	\item $\mathsf{ARTIC}$ by Komlo and Goldberg \cite{KomloG24}
	\item $\mathsf{HARTS}$ by Bacho, Loss, Stern and Wagner \cite{BachoLSW24}
\end{itemize}

There exist some multi-signature schemes in which the signature format is compatible with FIPs186-5 but the signature verifier is incompatible.
This includes
\begin{itemize}
	\item $\mathsf{MSDL}$ by Boneh, Drijvers, and Neven  \cite{BonehDN18}
	\item $\mathsf{MuSig}$ by Maxwell, Poelstra, Seurin, and Wuille \cite{MaxwellPSW19}
	\item $\mathsf{MuSig2}$ by Nick, Ruffing, and Seurin \cite{NickRS21}
	\item $\mathsf{MuSigDN}$ by Nick, Ruffling, Seurin, and Wuille \cite{NickRSW20}
\end{itemize}
We also exclude these schemes from our comparisons in this section.

\subsection{Key for \cref{table:comparisons}}\label{section:comparisons:tablekey}
We here give a key for understanding the comparisons in \cref{table:comparisons}.
Where applicable we follow the keys in the Call for Proposals.
\begin{itemize}
	\item The number of parties $n$ can either be:
	\begin{itemize}
		\item (2) ``two" for $n = 2$;
		\item (3) ``three" for $n = 3$;
		\item  (S) ``small" for $4 \leq n \leq 8$;
		\item  (M) ``medium" for $9 \leq n \leq 64$;
		\item (L) ``large" for $65 \leq n \leq 1024$; 
		\item (E) ``enormous" for $n > 1024$.
	\end{itemize}
	\item The corruption proportion $f/n$ can either be:  
		\begin{itemize}
			\item  (D) ``dishonest majority" for $f \geq n/2$; 
			\item  (h) ``honest majority” for $f < n/2$; 
			\item (H) “two-thirds honest majority” for $f < n/3$.
	\end{itemize}
	\item The assumptions can  be:
		\begin{itemize}
			\item $\dl$ ``discrete logarithm" if the $\dl$ assumption is required;
			\item $\aomdl$ ``Algebraic one more discrete logarithm" if the $\aomdl$ assumption is required.
		\end{itemize}
	\item 	The idealisation for all schemes includes the random oracle model and so this is not indicated in the table.  The additional idealisations can be:
		\begin{itemize}
			\item (G)  ``game based" for a game based security notion;
			\item (S) ``simulation" for a simulation based security notion;
			\item (AGM) ``algebraic group model" if the AGM is required.
		\end{itemize} 
 	\item The liveness guarantees can be
 		\begin{itemize}
 			\item  (IA) ``identifiable abort" if cheating parties can be identified;
 			\item  (h) ``robust under honest majority” if robustness holds given $f < n/2$;
 			\item (N) ``not robust against active adversaries". 
 		\end{itemize}
 	\item The adversary for all schemes we consider is active.  We write:
 		\begin{itemize}
 			\item (U)  ``unknown" for no known positive or negative adaptive result; 
 			\item (H) ``half" if adaptive security is provable for $f \leq \frac{k}{2}$
 			\item (F) ``full" for full adaptivity security i.e. adaptive security if provable for $f = k - 1$.
 		\end{itemize}
 	\item The number of rounds  can either be:
 	\begin{itemize}
 		\item (2) ``two" for $2$ rounds;
 		\item (3) ``three" for $3$ rounds;
 	\end{itemize}
 	\item The distributed system and communication requirements can be ......
 	\item The key generation can be ......
\end{itemize}   

\subsection{Concurrency}\label{section:comparisons:concurrency}
$\frost$ as well as all other schemes in this comparison is concurrently secure.  
There are no restrictions on the number of sessions a polynomial time adversary can have open at the same time.
This is a strict requirement in the call for proposals.

\subsection{Threshold Profiles}
$\frost$ is a $k$-out-of-$n$ threshold signature that supports any $1 \leq k \leq n$.
As in the Call for Proposals \cite{} we have: $k$ is the number of participants requires to sign; $f$ is the corruption proportion; and  $n$ is the number of parties.
The number of parties is enormous ($n > 1024$) although smaller $n$ is also supported.
The corruption proportion is dishonest majority ($f \geq \frac{n}{2}$) although smaller $f$ is also supported.
$\frost$'s corruption threshold is equal to the participation-minus-1 threshold $f = k-1$.
\mary{This may not be true for potential adaptive security reduction.}


\subsection{Security Assumptions}\label{section:comparisons:security}
$\frost$ is secure under the Algebraic-One-More-Discrete-Logarithm ($\aomdl$) problem \cite{NickRS21}.
This is a falsifiable assumption that holds in the generic group model \cite{CorettiDG18,BauerFP21}.
It is strictly better than the non-falsifiable One-More-Discrete-Logarithm problem \cite{BellareNPS03} because the adversary can only query on known linear combinations of fixed challenges,
as opposed to any group element.
It is strictly worse than the discrete-logarithm $(\dl)$ assumption under which the base EdDSA signature is secure.
An adversary that solves $\dl$ can also solve $\aomdl$, but an adversary that solves $\aomdl$ cannot necessarily solve $\dl$.

$\frost$ generates EdDSA signatures which cannot be post-quantum secure, because EdDSA depends on the discrete logarithm assumption.
There is a known quantum attack against the discrete logarithm problem \cite{Shor99}.



\subsection{Security Idealisation}\label{section:comparisons:idealisation}
The security reduction for $\frost$ is given under a game-based security formulation in the programmable random oracle model.
It is expected the idealised model for any threshold protocol producing EdDSA signatures must be stronger than the standard model.
This is because there is no security reduction for EdDSA without any random oracle~\cite{PaillierV05,FischlinF13,FleischhackerJS14}

There is no known security reduction for $\frost$ in the universal composability model.
To minimise the risks of composability attacks when $\frost$ is used in larger protocols,
it is important to prefix the hash digests with appropriate domain separators.
We fully specify the recommended domain separators in this document.

\subsection{Liveness}
$\frost$ is not  robust because there are no guarantees that any given session will terminate.
If a session does not terminate then this does not effect the unforgeability security guarantees.
$\frost$ does satisfy identifiable abort.  This means that if any party does not follow the honest signing protocol then they can be actively detected and removed from future iterations of the protocol.

\mary{Say something about robust competitors.}

\subsection{Adversary}\label{section:comparisons:adversary}
$\frost$ is actively secure.  An adversary can corrupt up to $f$ parties, controlling them to arbitrarily deviate from the prescribed multi-party protocol.
There is no adaptive security reduction for $\frost$, i.e., we cannot prove security against an adversary that can decide which parties to corrupt after observing some of the protocol execution.
However there is also no known adaptive attack against $\frost$.

\mary{
	Please help, I know little about this:
	The proposed threshold schemes should be compatible with modular subprotocols / mechanisms for proactive (and reactive) recovery, which attempt to recover possibly corrupted parties back to an uncorrupted state. This is especially important to better handle a persistent mobile adversary that continuously attempts to corrupt more parties. With respect to refreshing secret shares, the solutions can be based on a modularized phase of secret-resharing (see T6), while also specifying the needed conditions (e.g., requirement of some initial/final agreement by a qualified quorum) for its integration.
}

There exist $3$ round schemes that provably fully adaptive \cite{} in the algebraic group model with non-programmable random oracles.  However there is no static or adaptive security reduction of $\frost$ in this model.  

\subsection{Number of Rounds}\label{section:comparisons:rounds}
$\frost$ has $2$ signing rounds and allows the message to be determined in the second round of signing.
Thus $\frost$ allows for an effective non-interactive signing procedure assuming that a preprocessing phase is run in advance.
This is not possible for any threshold scheme producing EdDSA signatures that depends on $\dl$.

Currently there is no known efficient concurrently secure $2$-round threshold signature scheme that generates EdDSA signatures that is secure under $\dl$.
We do not know if this is fundamental or not.  However, there are efficient concurrently secure $3$-round threshold signature schemes \cite{Lindell22,Makriyannis22,CritesKM23}.
The $3$ round schemes require the message to be fixed in the first or second round of the protocol.

\subsection{Communication Complexity}\label{section:comparisons:communicationcomplexity}
A full theoretical and experimental break down of the communication complexity of $\frost$ is given in \cref{?}.
In each signing session all parties:  send $2 \Gr$ and $1 \F$; and receive $2 k \Gr$ as well as the message and signing set.

\subsection{State Management and Storage Requirements}
$\frost$ requires state management to ensure that:
(1) secret randomness from the first round is available to the signer in the second round;
(2) nonces from the first round are not used twice.
All schemes we compare against also require state management to ensure these two properties.
If the secret randomness from the first round is lost then the signer will not be able to take part in the second round.
If the nonces from the first round are used twice then an adversary can recover the signers partial secret key,
thus compromising the signer.

Unlike in FIPS186-5 it is important that nonces are not generated using deterministic randomness to prevent nonces from the first round being used twice.

As a two round scheme $\frost$ has simpler state management than the other threshold signatures we compare against.
For example $\frost$ does not need to track which round of signing each party is currently in.
There are no single round threshold signatures that product FIPS186-5 signatures.

To allow simulate non-interactive signing $\frost$ preprocesses numerous first round contributions for each signing party.
This is possible because $\frost$ signers do not learn the message or signing set until the second round.
This requires storage of the state for all (preprocessed) open sessions.
We only analyse security when the states are stored and managed exactly as specified in this document.
\mary{Check with others if this is okay.}
\liz{Is state updated, or is state maintained for each round?}

\subsection{Distributed Systems and Communication}



\subsection{Key Generation}\label{section:comparisons:keygeneration}
For simplicity we specify $\frost$ assuming a trusted setup procedure, where a single trusted user generates all key shares.
For many applications such as backups this suffices.
However  $\frost$ can be instantiated with any simulatable distributed key generation \cite{}.

%\begin{table}[htbp]
%	\centering
%	\begin{tabular}{c c c c c c c c}
%		\toprule
%		Scheme & \ $n$ \ & $f/n$ & Assumption & Ideal & Live & Adversary & Rounds \\ \midrule
%		GJKR01 \cite{GennaroJKR01}& & & & & & & \\ 
%		SS01 \cite{StinsonS01} & & & & &  & & \\
%		$\mathsf{2SCHNORR}$ & & & & & &  & \\
%		$\mathsf{CLASSICS}$ & & & & & & & \\
%		$\mathsf{ZEROS}$ & & & & & &   & \\
%		Lindell22 \cite{Lindell22} & E & D & $\dl$ & S &  IA, N & U & $3$ \\
%		$\mathsf{ROAST}$ & & & & &  & & \\
%		$\mathsf{SPARKLE}$ & E & D & $\dl$ & G & IA, N & H & $3$ \\
%		$\mathsf{SPARKLE}^*$ & E & D & $\dl$ & G, AGM & IA, N & F & $3$ \\
%		$\mathsf{SPRINT}$ & & & & & &  & \\
%		$\mathsf{ARTIC}$ & & & & & &  & \\
%		$\mathsf{HARTS}$ & & & & & &  & \\
%		\midrule 
%		$\mathsf{FROST}$ & E & D & $\aomdl$ & ROM & IA, N & U & $2$ \\
%		\bottomrule
%	\end{tabular}
%	\caption{\label{table:comparisons}
%		Table of comparisons with other schemes that are backwards compatible with the signature format and verifier of FIPS186-5.
%		We provide a key for interpreting this table in \cref{section:comparisons:tablekey}.
%	 }
%\end{table}


\section{System Model}\label{section:system-model}

\subsection{Participants}
Our system model is composed of a set of $n$ parties (or servers)$P_1, \dots, P_n$ that can be modeled by polynomial-time randomized Turing machines.

The communication complexity of the FROST signing protocol is $\BigO(\lambda n^2)$.

\subsection{Distributed Systems and Communication}

\begin{description}

\item[Synchrony.] FROST relies on a partially synchronous network.  Communication proceeds in synchronized rounds, and all protocol messages sent between honest parties arrive within some specified time bound.  To guarantee this round synchronization, we assume that the parties are equipped with synchronized clocks.  An adversary may be \emph{rushing}; that is, it may wait until all honest protocol messages have been sent before determining its own messages.

\item[Reliability.] All protocol messages between participants are sent using a reliable network channel.

\item[Broadcast.] FROST does not rely on a broadcast channel.  In particular, this means that an adversary could send different messages to different honest parties within the same signing session.  Authenticated channels are not assumed either; an adversary can decide which message to send to an honest party on behalf of another honest party.

\end{description}

FROST is not \emph{robust}, meaning that there is no guarantee that a signing session will terminate.
However, FROST does allow \emph{identifiable abort}. 




\subsection{Adversary}

One goal of an adversary is to forge a FROST signature.

\begin{description}

\item[Active.] FROST is secure against an active adversary, who is able to corrupt up to $f = t-1$ out of a threshold of $t$ parties (where $t \leq n$), controlling them to arbitrarily deviate from the prescribed multi-party protocol.

\item[Adaptive.] The stronger adaptive adversary is able to decide which parties to corrupt after observing some of the protocol execution. 
Upon corruption, the adversary learns the secret key and private state for the corrupted party in all open signing sessions.
Currently, there is no known proof of adaptive security for FROST.

\item[Mobile.] A mobile adversary ``persistently continues (attempting to) corrupt parties across multiple executions of the main protocol, possibly corrupting parties after they have been recovered from a previous corruption."
Currently, there is no known security proof for FROST capturing a mobile adversary.

\end{description}





